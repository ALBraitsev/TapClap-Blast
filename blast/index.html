<!DOCTYPE html>
<html>
<title>TAPCLAP Blast Test</title>

<body>
    <form>
        <div>
            <label for="geimBoardWidth">Geim Board Width (M):</label>
            <input type="number" id="geimBoardWidth" name="geimBoardWidth" min="2" max="12" value="10" required>

            <label for="geimBoardHeight">Geim Board Height (N):</label>
            <input type="number" id="geimBoardHeight" name="geimBoardHeight" min="2" max="12" value="10" required>

            <label for="colorsCount">Colors Count (C):</label>
            <input type="number" id="colorsCount" name="colorsCount" min="3" max="12" value="3" required>

            <label for="minSampleSize">Min Sample Size (K):</label>
            <input type="number" id="minSampleSize" name="minSampleSize" min="2" max="12" value="2" required>
        </div>
        <div>
            <input type="button" id="resetButton" value="Reset Game Board">
            <input type="button" id="shuffleButton" value="Shuffle Game Board">
        </div>
    </form>

    <canvas id="myCanvas" width="640" height="480" style="border:1px solid #000000;">
    </canvas>


    <script>
        class HSLColor {
            constructor(h, s, l, a = 100) {
                this.hue = h;
                this.saturation = s;
                this.lightness = l;
                this.alpha = a;
            }
            color() {
                return `hsla(${this.hue}deg, ${this.saturation}%, ${this.lightness}%, ${this.alpha}%)`
            }
            equal(color) {
                return this.hue == color.hue && this.saturation == color.saturation && 
                this.lightness == color.lightness && this.alpha == color.alpha;
            }
        };

        function getPalette(num_colors) {
            var palette = [];
            for (var i = 0, di = 360 / num_colors; i < 360; i += di) {
                var hue = i;
                var saturation = 90 + Math.random() * 10;
                var lightness = 50 + Math.random() * 10;
                palette.push(new HSLColor(hue, saturation, lightness));
            }
            return palette;
        }

        class Action {
            constructor (from, to, duration, actor) {
                this.from = from;
                this.to = to;
                this.duration = duration;
                this.actor = actor;
                this.part = 0;
            }
            // возвращает true если произошли изменения
            // иначе false
            update (timestamp) {
                if (this.part >= 1.0) return false;
                if (this.begin === undefined) this.begin = timestamp;
                this.part = this.duration == 0 ? 1.0 : (timestamp - this.begin) / this.duration;
                this.actor(this.from + (this.to - this.from) * Math.min(1.0, this.part));
                return true;
            }
        };
        class ActionSequence {
            constructor (actions) {
                this.actions = actions;
            }
            // возвращает true если произошли изменения
            // иначе false
            update (timestamp) {
                let isChanged = false;
                this.actions.forEach(
                    (action, index, actions) => { 
                        if (isChanged == false) {
                            isChanged ||= action.update(timestamp);
                            if (isChanged == false) {
                                actions.splice(index, 1);
                            }
                        }
                    }
                );
                return isChanged || this.actions.length > 0;
            }
        }

        class Tile {
            constructor(row, column, width, height, color) {
                this.row = row;
                this.col = column;
                this.width = width;
                this.height = height;
                this.color = color;
                this.animations = [];
            }
            draw(ctx) {
                ctx.fillStyle = this.color.color();
                ctx.fillRect(this.width * this.col, this.height * this.row, this.width, this.height);
            }
        };

        class GameBoard {
            constructor(canvas, M, N, C, K = 2) {
                this.canvas = canvas;
                this.columns = M;
                this.rows = N;
                this.colorsCount = C;
                this.minSampleSize = K;
                
                this.ctx2d = this.canvas.getContext("2d");
                this.palette = getPalette(this.colorsCount);
                this.tailWidth = this.canvas.width / this.columns;
                this.tailHeight = this.canvas.height / this.rows;

                this.tiles = [];
                for (var row = 0; row < this.rows; ++row) {
                    for (var column = 0; column < this.columns; ++column) {
                        var colorNumber = parseInt(Math.random() * this.colorsCount);
                        let hsl = this.palette[colorNumber];
                        this.tiles.push(new Tile(row, column, this.tailWidth, this.tailHeight, new HSLColor(hsl.hue, hsl.saturation, hsl.lightness, hsl.alpha)));
                    }
                }

                this.actions = [];

                this.canvas.removeEventListener('click', null);
                this.canvas.addEventListener('click', (event) => {this.onClick(event);});

                this.raf = window.requestAnimationFrame((timestamp)=>{this.update(timestamp);});
                this.isChanged = true;
            }
            release() {
                window.cancelAnimationFrame(this.raf);
            }

            update(timestamp) {
                let isChanged = this.isChanged;
                this.isChanged = false;
                this.actions.forEach(
                    (action, index, actions) => { 
                        // console.log("Action " + index);
                        let updated = action.update(timestamp);
                        this.isChanged ||= updated;
                        if (updated == false) actions.splice(index, 1);
                    }
                );
                this.raf = window.requestAnimationFrame((timestamp)=>{this.update(timestamp);});

                if(isChanged == true) this.draw();
            }

            draw() {
                this.ctx2d.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.tiles.forEach((n, i) => { if (n) n.draw(this.ctx2d) });
                console.log("GameBoard::draw");
            }
            shuffleTiles() {
                for (let i = this.tiles.length - 1; i > 0; --i) {
                    let j = Math.floor(Math.random() * (i + 1));
                    if (this.tiles[i] != null && this.tiles[j] != null) {
                        [this.tiles[i].color, this.tiles[j].color] = [this.tiles[j].color, this.tiles[i].color];
                    }
                }
                this.isChanged = true;
            }
            getTileNumbersToRemove(idx, row, col, color = null) {
                var npp = row * this.columns + col;

                if (idx.includes(npp)) return;
                if (this.tiles[npp] == null) return;

                if (color) {
                    if (this.tiles[npp].color.equal(color)) {
                        idx.push(npp);
                    }
                    else {
                        return;    
                    }
                }
                else {
                    idx.push(npp);
                }

                if (row > 0) this.getTileNumbersToRemove(idx, row - 1, col, this.tiles[npp].color);
                if (row < this.rows - 1) this.getTileNumbersToRemove(idx, row + 1, col, this.tiles[npp].color);
                if (col > 0) this.getTileNumbersToRemove(idx, row, col - 1, this.tiles[npp].color);
                if (col < this.columns - 1) this.getTileNumbersToRemove(idx, row, col + 1, this.tiles[npp].color);
            }

            onClick(event) {
                if (this.isChanged) return;
                console.log("onClick" + this.isChanged);

                var row = parseInt(event.layerY / this.tailHeight);
                var col = parseInt(event.layerX / this.tailWidth);

                var tileNumbersToRemove = [];
                this.getTileNumbersToRemove(tileNumbersToRemove, row, col);

                if (tileNumbersToRemove.length >= this.minSampleSize) {


                    tileNumbersToRemove.forEach((n) => {
                            this.actions.push(new ActionSequence([
                                new Action(100,0,200,(v)=>{this.tiles[n].color.alpha = v;}),
                                new Action(0,0,0,(v)=>{this.tiles[n] = null;})
                            ]));
                        }
                    );

                    this.isChanged = true;
                }
            }
        };

        var gameBoard = null;

        var resetButton = document.getElementById("resetButton");
        resetButton.addEventListener('click', function (event) {
            var canvas = document.getElementById("myCanvas");
            var M = parseInt(document.getElementById("geimBoardWidth").value);
            var N = parseInt(document.getElementById("geimBoardHeight").value);
            var C = parseInt(document.getElementById("colorsCount").value);
            var K = parseInt(document.getElementById("minSampleSize").value);

            if (gameBoard) gameBoard.release();
            gameBoard = new GameBoard(canvas, M, N, C, K);
        });

        var shuffleButton = document.getElementById("shuffleButton");
        shuffleButton.addEventListener('click', function (event) {
            if (gameBoard != null) {
                gameBoard.shuffleTiles();
            }
        });

    </script>
</body>

</html>
